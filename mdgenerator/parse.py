import re as re
import sys

# The timefield function expands a short month string generated by date.sh to a long form markup date.
def timefield (matchingGroup):
    def f(x):
        months = {'Jan':'January',
              'Feb':'February',
              'Mar':'March',
              'Apr':'April',
              'May':'May',
              'Jun':'June',
              'Jul':'July',
              'Aug':'August',
              'Sep':'September',
              'Oct':'October',
              'Nov':'November',
              'Dec':'December'}
        
        out = matchingGroup.group(x)
        
        if x == 'month':
            out = months[out]
        
        return out
    
    return f

def daystamp(mgrp):
    fg = timefield(mgrp)
    return fg('month')+' '+fg('day')+', '+fg('year')
    
def timestamp(mgrp):
    fg = timefield(mgrp)
    hour = int(fg('hour'))
    return str(hour%12 + (not hour%12)*12)+':'+fg('minute')+' '+ ('pm' if hour/12 else 'am')

# Escape special characters in markdown
def escapeMD(mathstring):
    for x in '\`*_{}[]()#+-.~':
        mathstring = mathstring.replace(x,"\\"+x) 
    return mathstring

# For each inline math string found using re.sub, escape the first matched
# group and nest it in the characters needed to survive markdown rendering
def escapeInline(s):
    return '\\\\(' + escapeMD(s.group(1)) + '\\\\)'

# Match the date strings with named regexp groups for each field.
dateRegExp = r'#\((?P<dayname>\w+)\s+(?P<month>\w+)\s+(?P<day>\w+)\s+(?P<hour>[\w:]+):(?P<minute>[\w:]+):(?P<second>[\w:]+)\s+(?P<timezone>\w+)\s+(?P<year>\w+)\)'
dsmatch = lambda x: re.match(dateRegExp,x)

mathChars  = r'([\w\s\a\\\^\[\$\.\,\|\?\*\+\-\(\)\{\}=/~#]*)'
# Regexp for \[ \] delimited equations.
mathRegExp = r'\\\[' + mathChars + r'\\\]'
mathmatch = lambda x: re.match(mathRegExp,x)

# Regexp for inline \( \) delimited equations.
mathRegExp_inline = re.compile(r'\\\(' + mathChars + r'\\\)')
mathmatch_inline = lambda x: mathRegExp_inline.search(x)

# The following flag is flipped on upon entering a math environment like the align latex environment
inEnvironment = 0
envRegExp = re.compile(r'\\(begin|end){\w+}')
envmatch  = lambda x: envRegExp.search(x)

fname = sys.argv[1]
with open(fname) as f:
    for line in f:
        tmstmp = dsmatch(line)
        math   = mathmatch(line)
        math2  = mathmatch_inline(line)
        # If the line a date string denoted #(...)
        if tmstmp:
            # format and print it.
            print('<p class="daystamp">'+daystamp(tmstmp)+'</p>')
            print('<p class="timestamp">'+timestamp(tmstmp)+'</p>')
        else:
            math = mathmatch(line)
            math2 = mathRegExp_inline.search(line)
            
            # At the beginning of an environment, flip the env flag.
            if envmatch(line):
                inEnvironment = inEnvironment^1
            # In an environment, escape the line.
            elif inEnvironment:
                line = escapeMD(line)
            # Otherwise check the line for a default math environment
            elif math:
                escapedMathString = escapeMD(math.group(1))
                line = '\\\\\[' + escapedMathString + '\\\\\]\n'
            # or an inline environment and escape it.
            elif math2:
                line = mathRegExp_inline.sub(escapeInline,line)
            
            # Finally print the line.
            print(line,end="")
